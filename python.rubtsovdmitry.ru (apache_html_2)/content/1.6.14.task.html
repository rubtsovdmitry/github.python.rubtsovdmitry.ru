<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta name="Dmitry Rubtsov." content="Dmitry Rubtsov.">
		<meta name="generator" content="Bluefish 2.2.14" >
		<meta charset="utf-8">
		<link rel="stylesheet" href="content.css">		
		<title> 14. Факториалы. </title>		
	</head>
	<body>
		<h1> 14. Факториалы. </h1>
		<hr>
		<div> 
			<span> Условие: </span> <br>
			<hr>			
			Составить словарь, где ключ - это целое число (от 1 до 30 включительно), а значение - это факториал этого числа <br>
			1!  = 1 <br>
			2!  = 1×2 <br>
			5!  = 1×2×3×4×5 <br>
			10! = 1×2×3×...×9×10 = 9!×10 <br>
			Программа спрашивает у пользователя число, и выводит его факториал. Это повторяется до тех пор, пока пользователь не ввёл -1. Причём: <br>
			• Если факториал этого числа уже как-то ранее вычислялся, то программа берёт готовое число. <br>
			• Если нет, то программа считает его от ближайшего ранее вычисленного факториала. <br>
			Нужно свести к минимуму количество операций умножения. Пример: <br>
			Пользователь ввёл 5: <br>
			> Считаем факториал 5, попутно вычисляя факториалы 4, 3 и 2. Все значения сохраняем в кэше. <br>
			Пользователь ввёл 3: <br>
			> Такой факториал мы только что сосчитали, пока считали факториал пяти, берём готовое значение из кэша. <br>
			Пользователь ввёл 7 <br>
			> Такой факториал мы не считали, но знаем факториал 5. Поэтому считаем его как 5! * 6 * 7. 
		</div>		
		<hr>
		<div>
			<span> Код: </span>
		</div>
		<hr>
		<pre>
result_dict = {1:1}                                                        # этот словарь будем дополнять готовыми результатами, стартует уже с минимальными данными для цифры 1

number = int(input("Введите число:")    )                                  
while number > 0:                                                          # в цикле будет спрашивать о новом числе, пока не введёшь отрицательное число        
    if number in result_dict.keys(): 
        print("Для числа", number, "факториал равен", result_dict[number])
    elif number not in result_dict.keys():
        work_range = range((max(result_dict.keys()) + 1), number + 1)      # создание range, кот. будем обходить в цикле  
        composition = result_dict[max(result_dict.keys())]                 # вынимаем максимальное значение из существующего словаря
        for i in work_range:                                               # обойдём в цикле все числа в range        
            composition *= i                                               # считаем новое произведение факториала
            result_dict[i] = composition                                   # создаём ключ в словаре со значением переменной "composition"
        print("Для числа", number, "факториал равен", result_dict[number])
    number = int(input("Введите число:"))
		</pre>				
	</body>
</html>